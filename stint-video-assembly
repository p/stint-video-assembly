#!/usr/bin/env ruby

require 'byebug'
require 'json'
require 'open3'
require 'yaml'
require 'optparse'

class Hash
  def stringify_keys
    out = {}
    each do |k, v|
      out[k.to_s] = v
    end
    out
  end
  
  def deep_stringify_keys
    out = {}
    each do |k, v|
      if v.is_a?(Hash)
        v = v.deep_stringify_keys
      end
      out[k.to_s] = v
    end
    out
  end
end

options = {}

OptionParser.new do |opts|
  opts.on('-s', '--skeleton', 'Create a skeleton configuration file') do
    options[:skeleton] = true
  end
  
  opts.on('-b', '--build-meta', 'Build video meta info') do
    options[:build_meta] = true
  end
end.parse!

def video_file?(path)
  %w(mov mkv).include?(path.sub(/.*\./, '').downcase)
end

$size_cache = {}
def cached_file_size(path)
  $size_cache[path] ||= File.stat(path).size
end

def size_reasonable?(path)
  cached_file_size(path) > 50_000_000
end

class Generator
  attr_reader :root
  
  def initialize(root)
    @root = root
  end
  
  private def video_file_paths
    paths = []
    Dir["#{root}/*"].sort.each do |path|
      filename = File.basename(path)
      if video_file?(filename) && size_reasonable?(path)
        paths << path
      end
    end
  end
end

class SkeletonGenerator < Generator
  def generate
    skeleton = {}

    video_file_paths.each do |path|
      filename = File.basename(path)
      skeleton[filename] = {
        split: nil,
        join: nil,
        size: human_size(path),
      }
    end
    
    skeleton
  end
  
  private def human_size(path)
    (cached_file_size(path) / 1024 / 1024).round.to_s + ' MB'
  end
end

class MetaGenerator < Generator
  def generate
    video_file_paths.each do |path|
      key_frame_times = FfProbe.new(path).key_frame_times
      open("#{path}.keyframes.json", 'w') do |f|
        f << JSON.dump(key_frame_times)
      end
    end
  end
end

class Splitter
  def initialize(config)
    @config = config
  end
  
  attr_reader :config
  
  def run
    config.each do |filename, subconfig|
      splits = subconfig['split']
      if splits == 'none'
        puts "Ignore #{filename}"
        next
      end
      
      if splits.is_a?(Hash) && splits.size == 1 && splits.values == [nil]
        splits = splits.keys.first
      end
      
      if splits.is_a?(String)
        # single split, do we need to change file format?
        if splits =~ /-p\d+$/ || splits.include?('.')
          # yes
          splits = {splits => {}}
        else
          new_name = make_new_name(filename, splits)
          puts "Rename #{filename} -> #{new_name}"
          next
        end
      end
      
      splits.each do |target, split_config|
        if split_config == {}
          # format conversion only
          new_name = make_new_name(filename, target, 'mkv')
          puts "Convert all #{filename} -> #{new_name}"
        else
          # ranged conversion
          info = FfProbe.new(filename)
          p info.length
          p info.key_frame_times
          byebug
          x
        end
        p split_config
      end
      
      p filename
    end
  end
  
  private def make_new_name(filename, target, new_ext=nil)
    if target.include?('.')
      target
    else
      if new_ext.nil?
        unless filename =~ /\.(\w+)$/
          raise "Can't figure out the extension for #{filename}"
        end
        new_ext = $1.downcase
      end
      "#{target}.#{new_ext}"
    end
  end
end

module Utils
  module_function def duration_to_length(duration)
    unless duration =~ /^(((\d+):)?(\d+):)?(\d+)(\.\d+)$/
      raise "Bad duration format: #{duration}"
    end
    
    h, m, s, ms = $3, $4, $5, $6
    h.to_i * 3600 + m.to_i * 60 + s.to_i + "0#{ms}".to_f
  end
end

class FfProbe
  def initialize(path)
    @path = path
  end
  
  attr_reader :path
  
  def info
    @info ||= JSON.parse(get_output(
      'ffprobe', '-v', 'quiet', '-print_format', 'json',
      '-show_format', path))
  end
  
  def length
    info['format']['duration'].to_f
  end
  
  def key_frame_times
    @key_frame_times ||= begin
      info = JSON.parse(get_output(
        'ffprobe', '-v', 'quiet', '-print_format', 'json',
        path,
        '-select_streams', 'v', '-show_frames', '-show_entries', 'frame=pkt_pts_time,pict_type'))
      info = info['frames']
      key_frame_times = []
      info.each do |frame_info|
        if frame_info['pict_type'] == 'I'
          key_frame_times << frame_info['pkt_pts_time'].to_f
        end
      end
      key_frame_times
    end
  end
  
  private def get_output(*cmd)
    output, status = Open3.capture2(*cmd)
    if status.exitstatus != 0
      raise "Command failed: #{cmd.join(' ')}: #{status.exitstatus}"
    end
    output
  end
end

if File.basename($0) == File.basename(__FILE__)
  if options[:skeleton]
    payload = SkeletonGenerator.new(Dir.pwd).generate.deep_stringify_keys
    puts YAML.dump(payload)
    exit
  elsif options[:build_meta]
    MetaGenerator.new(Dir.pwd).generate
    exit
  end

  config = YAML.load(File.open(ARGV.first).read)

  Splitter.new(config).run
end

