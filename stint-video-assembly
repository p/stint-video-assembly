#!/usr/bin/env ruby

require 'json'
require 'open3'
require 'yaml'
require 'optparse'

class Hash
  def stringify_keys
    out = {}
    each do |k, v|
      out[k.to_s] = v
    end
    out
  end
  
  def deep_stringify_keys
    out = {}
    each do |k, v|
      if v.is_a?(Hash)
        v = v.deep_stringify_keys
      end
      out[k.to_s] = v
    end
    out
  end
end

options = {}

OptionParser.new do |opts|
  opts.on('-s', '--skeleton', 'Create a skeleton configuration file') do
    options[:skeleton] = true
  end
end.parse!

def video_file?(path)
  %w(mov mkv).include?(path.sub(/.*\./, '').downcase)
end

$size_cache = {}
def cached_file_size(path)
  $size_cache[path] ||= File.stat(path).size
end

def size_reasonable?(path)
  cached_file_size(path) > 50_000_000
end

class SkeletonGenerator
  attr_reader :root
  
  def initialize(root)
    @root = root
  end
  
  def generate
    skeleton = {}

    Dir["#{root}/*"].sort.each do |path|
      filename = File.basename(path)
      if video_file?(filename) && size_reasonable?(path)
        skeleton[filename] = {
          split: nil,
          join: nil,
          size: human_size(path),
        }
      end
    end
    
    skeleton
  end
  
  private def human_size(path)
    (cached_file_size(path) / 1024 / 1024).round.to_s + ' MB'
  end
end

class Splitter
  def initialize(config)
    @config = config
  end
  
  attr_reader :config
  
  def run
    config.each do |filename, subconfig|
      splits = subconfig['split']
      if splits == 'none'
        puts "Ignore #{filename}"
        next
      end
      
      if splits.is_a?(Hash) && splits.size == 1 && splits.values == [nil]
        splits = splits.keys.first
      end
      
      if splits.is_a?(String)
        # single split, do we need to change file format?
        if splits =~ /-p\d+$/ || splits.include?('.')
          # yes
          splits = {splits => {}}
        else
          new_name = make_new_name(filename, splits)
          puts "Rename #{filename} -> #{new_name}"
          next
        end
      end
      
      splits.each do |target, split_config|
        if split_config == {}
          # format conversion only
          new_name = make_new_name(filename, target, 'mkv')
          puts "Convert all #{filename} -> #{new_name}"
        else
          # ranged conversion
          info = FfProbe.new(filename)
          p info.length
        end
        p split_config
      end
      
      p filename
    end
  end
  
  private def make_new_name(filename, target, new_ext=nil)
    if target.include?('.')
      target
    else
      if new_ext.nil?
        unless filename =~ /\.(\w+)$/
          raise "Can't figure out the extension for #{filename}"
        end
        new_ext = $1.downcase
      end
      "#{target}.#{new_ext}"
    end
  end
end

module Utils
  module_function def duration_to_length(duration)
    unless duration =~ /^(((\d+):)?(\d+):)?(\d+)(\.\d+)$/
      raise "Bad duration format: #{duration}"
    end
    
    h, m, s, ms = $3, $4, $5, $6
    h.to_i * 3600 + m.to_i * 60 + s.to_i + "0#{ms}".to_f
  end
end

class FfProbe
  def initialize(path)
    output, status = Open3.capture2('ffprobe', '-v', 'quiet',
      '-print_format', 'json', '-show_format', path)
    begin
      if status.exitstatus != 0
        raise "Command failed: ffprobe #{path}: #{status.exitstatus}"
      end
      @info = JSON.parse(output)
    ensure
      output.close
    end
  end
  
  def length
    @info['format']['duration'].to_f
  end
end

if File.basename($0) == File.basename(__FILE__)
  if options[:skeleton]
    payload = SkeletonGenerator.new(Dir.pwd).generate.deep_stringify_keys
    puts YAML.dump(payload)
    exit
  end

  config = YAML.load(File.open(ARGV.first).read)

  Splitter.new(config).run
end
